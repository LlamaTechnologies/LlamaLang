/*
  This file contains modifyed software from odin source-code
  so the next license is pasted.
*/
/* gb.h - v0.33  - Ginger Bill's C Helper Library - public domain
                 - no warranty implied; use at your own risk

  This is a single header file with a bunch of useful stuff
  to replace the C/C++ standard library

  IMPORTANT NOTE: THIS IS A HEAVILY MODIFIED VERSION OF THE ORIGINAL
  DO NO REPLACE IT WITH THE ORIGINAL
*/

#include "unicode.hpp"

#ifndef is_between
  #define is_between(x, lower, upper) (((lower) <= (x)) && ((x) <= (upper)))
  #define cast(type) (type)
#endif

// NOTE(bill): Because a signed sizeof is more useful
#ifndef gb_size_of
  #define gb_size_of(x) (u64)(sizeof(x))
#endif

typedef struct Utf8AcceptRange {
  u8 lo, hi;
} Utf8AcceptRange;

LL_LOCAL
u8 const global__utf8_first[256] = {
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x00-0x0F
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x10-0x1F
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x20-0x2F
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x30-0x3F
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x40-0x4F
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x50-0x5F
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x60-0x6F
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x70-0x7F
  0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0x80-0x8F
  0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0x90-0x9F
  0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0xA0-0xAF
  0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0xB0-0xBF
  0xf1, 0xf1, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, // 0xC0-0xCF
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, // 0xD0-0xDF
  0x13, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x23, 0x03, 0x03, // 0xE0-0xEF
  0x34, 0x04, 0x04, 0x04, 0x44, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0xF0-0xFF
};

LL_LOCAL
Utf8AcceptRange const global__utf8_accept_ranges[] = {
  { 0x80, 0xbf }, { 0xa0, 0xbf }, { 0x80, 0x9f }, { 0x90, 0xbf }, { 0x80, 0x8f },
};

u64 utf8_decode(u8 const *str, u64 str_len, rune *codepoint_out) {
  u64 width = 0;
  rune codepoint = UTF_INVALID_RUNE;

  if (str_len > 0) {
    u8 s0 = str[0];
    u8 x = global__utf8_first[s0];
    u8 b1, b2, b3, sz;
    Utf8AcceptRange accept;
    if (x >= 0xf0) {
      rune mask = (cast(rune) x << 31) >> 31;
      codepoint = (cast(rune) s0 & (~mask)) | (UTF_INVALID_RUNE & mask);
      width = 1;
      goto end;
    }
    if (s0 < 0x80) {
      codepoint = s0;
      width = 1;
      goto end;
    }

    sz = x & 7;
    accept = global__utf8_accept_ranges[x >> 4];
    if (str_len < gb_size_of(sz))
      goto invalid_codepoint;

    b1 = str[1];
    if (b1 < accept.lo || accept.hi < b1)
      goto invalid_codepoint;

    if (sz == 2) {
      codepoint = (cast(rune) s0 & 0x1f) << 6 | (cast(rune) b1 & 0x3f);
      width = 2;
      goto end;
    }

    b2 = str[2];
    if (!is_between(b2, 0x80, 0xbf))
      goto invalid_codepoint;

    if (sz == 3) {
      codepoint = (cast(rune) s0 & 0x1f) << 12 | (cast(rune) b1 & 0x3f) << 6 | (cast(rune) b2 & 0x3f);
      width = 3;
      goto end;
    }

    b3 = str[3];
    if (!is_between(b3, 0x80, 0xbf))
      goto invalid_codepoint;

    codepoint = (cast(rune) s0 & 0x07) << 18 | (cast(rune) b1 & 0x3f) << 12 | (cast(rune) b2 & 0x3f) << 6 |
                (cast(rune) b3 & 0x3f);
    width = 4;
    goto end;

invalid_codepoint:
    codepoint = UTF_INVALID_RUNE;
    width = 1;
  }

end:
  if (codepoint_out)
    *codepoint_out = codepoint;
  return width;
}
